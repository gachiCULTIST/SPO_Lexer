number /[0-9]+(\.[0-9]*)?([eE][\+\-]?[0-9]+)?/ { Double.Parse(text) }
plus /\+/ {text}
minus /\-/ {text}
pow /^/ {text}
division /\// {text}
multiply /\*/ {text}
id /[a-z_][a-z_0-9]*/ {text}
lparen /\(/ {text}
rparen /\)/ {text}
comma /,/ {text}
init /=/ {text}
def /def:/ {text}
/ +/
call /:call/ {text /* мне лень вручную это добавлять в перечисление */}

%%

%top {
	using LexSyntGenerator;
}

D -> def id init E { Variable.defineVar(_2, Node.stack) }
  | def id lparen A rparen init E { Function.defineFunc(_2, Node.stack) }
  | E {_1}
;

A -> id comma A { Function.addParam(_1 as string) }
  | id { Function.addParam(_1 as string) }
  |
;
E -> E plus T { Node.createNode(new Token(TokenType.Tok_plus, _2), Node.stack, 2) } 
  | E minus T { Node.createNode(new Token(TokenType.Tok_minus, _2), Node.stack, 2) }
  | T {_1}
;
T -> T multiply F { Node.createNode(new Token(TokenType.Tok_multiply, _2), Node.stack, 2) }
  | T division F  { Node.createNode(new Token(TokenType.Tok_division, _2), Node.stack, 2) }
  | F {_1}
;
F -> V pow F { Node.createNode(new Token(TokenType.Tok_pow, _2), Node.stack, 2) }
  | V {_1}
;
V -> lparen E rparen { Node.createNode(new Token(TokenType.Tok_lparen, "()"), Node.stack, 1) }
  | id lparen P rparen { Node.createNode(new Token(TokenType.Tok_call, _1), Node.stack, 0) }
  | id { Node.createNode(new Token(TokenType.Tok_id, _1), Node.stack, 1) }
  | number { Node.createNode(new Token(TokenType.Tok_number, _1), Node.stack, 1) }
  | minus V { Node.createNode(new Token(TokenType.Tok_minus, _1), Node.stack, 1) }
;

P -> E comma P
  | E
  |
;